const { test } = require('./lib')
// const daggy = require('daggy')

const { of, empty } = require('../src/quasi.js')
const fl = require('../src/fl.js')

const Identity = require('./common/Identity.js')
const List = require('./common/List.js')
// const Pair = require('./common/Pair.js')
// const Func = require('./common/Func.js')
// const Task = require('./common/Task.js')

test('eq', t => {
  const a = 'a'
  const as = List.Cons(a, List.Nil)
  t.notThrow(() => {
    t.eqFL(of(0), of[fl.chainRec]((next, done, v) => of(v === 0 ? done(v) : next(v - 1)), 100000))
  }, 'chainRec is stacksafe')
  t.throws(() => { empty[fl.map](a => a) }, 'throws on method calls which need value', TypeError)
  t.throws(() => { empty[fl.ap](a => a) }, 'throws on method calls which need value', TypeError)
  t.throws(() => { empty[fl.chain](a => a) }, 'throws on method calls which need value', TypeError)
  t.eqFL(Identity(0), of[fl.chainRec]((next, done, v) => Identity(v === 0 ? done(v) : next(v - 1)), 10))
  t.eqFL(Identity(10), of[fl.chainRec]((_, done, v) => Identity(done(v)), 10))
  t.eqFL('<of>(a)', of(a).toString())
  t.eqFL('<of>(<empty>)', of(empty).toString())
  t.ok(of(a)[fl.equals](Identity[fl.of](a)))
  t.ok(of(empty)[fl.equals](empty))
  t.ok(of(empty)[fl.equals](of(empty)))
  t.ok(empty[fl.equals](of(empty)))
  t.ok(empty[fl.equals](empty))
  t.notOk(of(a)[fl.equals](a))
  t.eqFL(of(empty), of(empty)[fl.concat](of(empty)))
  t.eqFL(of(empty), empty[fl.concat](of(empty)))
  t.eqFL(of(empty), of(empty)[fl.concat](empty))
  t.eqFL(Identity(as), of(as)[fl.concat](Identity(List.Nil)))
  t.eqFL(Identity(a), Identity(empty)[fl.concat](of(a)))
  t.eqFL(of(Identity(a)), of(a)[fl.map](a => Identity(a)))
  t.eqFL(of(a), of(a)[fl.chain](a => of(a)[fl.chain](of)))
  t.eqFL(of(a), of(a)[fl.chain](of)[fl.chain](of))
  t.eqFL(of(a), of(a)[fl.ap](of(a => a)))
  t.eqFL(Identity(a), of(a)[fl.chain](a => Identity(a)))
  t.eqFL(of(Identity(a)), of(a)[fl.ap](of(a => Identity(a))))
  t.eqFL(Identity(a), of(a)[fl.ap](Identity(a => a)))
  t.eqFL(Identity(a), of(a)[fl.ap](of(a => a))[fl.chain](a => of(a))[fl.chain](a => Identity(a)))
  t.eqFL(Identity(a), of(a)[fl.ap](Identity(a => a)))

  t.end()
})
